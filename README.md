# Поиск пары двух максимальных жлементов массива.

```C++
std::pair<int, int> getTwoMaxElementFromVector(const std::vector<int> &arr) {
    // 1. Проверка на размер массива
    //    Она должна быть в любом случае, в варианте где я коворил про 3 строчки,
    //    то эти две строки должны были быть как:
    //      assert((arr.size() < 2));
    if (arr.size() < 2)
        return std::pair<int, int>(-1, -1);

    // 2. Алгоритма поиска ДВУХ максимальных значений
    //    Предлагаю несколько вариантов
#ifndef STUPID
    // Обзначим этот вариант как stupid, идея максимально простая -
    // отсортировать массив и взять два максимальных элемента, НО так как
    // Массив константный, то это не вариант, его надо дополнительно скопировать,
    // в буфер. Если честно, я и предполагал это решение. Так как я считаю что код
    // Должен быть легко читаемым, и три строки(первая проверка, вторая сортировка и
    // третья возврат значения) читаются легко + в книгах пишут максимально короткие функции.
    // Но Денис Алексеевич добавил const тогда решение не подходит. Хотя я бы такое принял.
#elif 1
    // Второй вариант: Идея заключается в том, что мы сразу берем первый и второй элемент массива,
    // И сравниваем их с последующими. Сложность O(N), так как обход только 1. Явлется весьма оптимальным
    auto Max = (arr[0] > arr[1]) ? std::pair<int, int>(arr[0], arr[1]) : std::pair<int, int>(arr[1], arr[0]);
    for (size_t i = 2; i < arr.size(); i++) {
        if (Max.first < arr[i]) {
            Max.second = Max.first;
            Max.first = arr[i];
        } else if (Max.second < arr[i]) {
            Max.second = arr[i];
        }
    }
    return Max;
#elif 0
    // Есть еще третий способ решить эту задачу, спомощью указателей идти слева и справа по вектору.
    // Буду честен, я не очень понял этот способ, в пример привести не смогу.
    // Но как сказал Денис Алексеевич, такой способ есть.
#endif
	return std::pair<int, int>(0, 0);
}
```

Пример должны содержать возможные слабые места.

```cmd
-> % make; ./main
rm -rf ./main
g++ -Wall -Wextra -Werror -ansi -O3 -std=c++17 -lm -o ./main ./main.cpp ./test/CPUTime.cpp
Тест №  1| SUCCESS
Тест №  2| SUCCESS
Тест №  3| SUCCESS
Тест №  4| SUCCESS
Тест №  5| SUCCESS
Тест №  6| SUCCESS
Тест №  7| SUCCESS
Тест №  8| SUCCESS
Тест №  9| SUCCESS
Тест № 10| SUCCESS
```

# Про 16-ричную систему

Числа в 16-ричной системе счисления представлены тетрадами, 1 байт равен двум тетрадам, в результате
число в 16-ричной системе (в Си/Си++ оно начинается с *0х*) например 0х22 = '0010 0010', 0x3F = '0011 1111' и тд.
Чтобы быстро считать такие числа надо хорошо помнить такую таблицу только и всего.

```cmd
0000 0
0001 1
0010 2
0011 3
0100 4
0101 5
0110 6
0111 7
1000 8
1001 9
1010 A
1011 B
1100 C
1101 D
1110 E
1111 F
```


